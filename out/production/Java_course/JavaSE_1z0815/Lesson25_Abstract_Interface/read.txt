    Abstract class and abstract method
    Абстрактный класс задает категорию или общий объект, являющийся основой для остальных потомков. Например, для квадрата,
прямоугольника, круга, треугольника категорией является фигура. Известно, что фигура имеет количество сторон, площадь, периметр.
Однако, для каждой фигуры свои методы расчета. Для квадрата - это 4 стороны, S=a*a, P=4*a, для прямоугольника - это 4 стороны,
S=a*b, P=(a+b)*2.
    Внутри abstract класса могут быть abstract методы, могут быть и обычные методы. Первые объявляются без тела, которые впоследствие
перезаписывается потомком. Потомок, перезаписавший все методы abstract родителя, называется конкретным классом. Если потомок не
этого не сделает, то он тоже должен объявлен abstract. Если внутри обычного не abstract класса объявлен abstract метод, то класс
обязан быть абстрактным. Абстрактный класс может иметь обычные методы с телом.
    Как абстрактный класс, так и абстрактный метод должен наследоваться и перезаписываться. Исходя из этого, final, private,
static не употребляются с abstract.

    Interface
    Представляет собой контракт, который должен выполнить класс. При невыполнении интерфейса класс обязан стать абстрактным.
    Интерфейс решает две проблемы: множественное наследование и полиформизм объектов(можно не разбираться в полном устройстве
класса, а сразу пользоваться методами). До 8 версии в интерфейсе можно создавать абстрактные методы и переменные. По умолчанию к
каждому методу будут дописываться public abstract, к переменной - public final static, значит, при написании методов можно
ограничиться только return type'ом и сигнатурой, при написании переменной - типом и идентификатором.
    Рассмотрим свойства интерфейса:
    1. по умолчанию всегда абстрактный;
    2. создан только для реализации, поэтому не имеет конструкторов и не може быть final;
    3. между классом, реализующим интерфейс и интерфейсом существует связь "is-a", поэтому возможна такая запись:
                                Интерфейс id_variable = new Класс_реализующийИнтерфейс();
    Также как и у классов здесь действует buiding: перезаписанные методы будут вызываться у класса(runtime buiding), а переменные
и static методы у интерфейса(compile buiding).
    4. интерфейсы наследуют друг друга;

    В 8-ой версии языка в интерфейсах можно прописывать методы с телом. Тогда к ним приписывается модификатор default.